---
title: "Modeling replicated measurements with Stan"
author: "LC"
date: '2022-05-02'
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---

Load packages:

```{r setup, warning = F, message = F}
library(tidyverse)
library(cmdstanr)
library(posterior)
```

```{r setup2, include = F, echo = F}

register_knitr_engine()

```

Noisy data are simulated. True_x is the latent true predictor variable. x1 and x2 are noisy measurements of true_x. The outcome y is normally distributed. The regression coefficient of y on true_x is 0.5. The aim here is to see how well different methods are able to recover that true coefficient.

```{r simulate_data}

# simulate noisy x data

set.seed(3000)

d <- tibble(
  true_x = rnorm(100),
  y = 0.5*true_x + rnorm(100),
  # observed x values
  x1 = true_x + rnorm(100, sd = 1),
  x2 = true_x + rnorm(100, sd = 1))

```

Add data to list for Stan: 

```{r}

stan_data <- list(
  N = nrow(d),
  Nmeasurements = ncol(d[,c("x1","x2")]),
  y = d$y,
  x = d[,c("x1","x2")]
)


```

### Model 1 - flat priors ###

Now the Stan model is specified. The model, in statistical notation, is: 
$$ x_{obs,nj} \sim N(x_{true,n} , \sigma_x) $$
$$ y_n \sim N(\alpha + \beta * x_{true,n}, \sigma_y) $$
For this first model, flat priors are used for all parameters.


```{stan specify_model1, output.var = "latent_x_mod1"}

data {
  int N;                        // umber of individuals
  int Nmeasurements;            // number of replicates
  vector[N] y;                  // outcome
  matrix[N, Nmeasurements] x;   // N by Nmeasurements matrix x 
}

parameters {
  real<lower=0> sigma_x;    // sigma of latent true x
  vector[N] true_x;         // latent true x

  real<lower=0> sigma_y;    // sigma of y
  real alpha;               // intercept
  real beta;                // coefficient beta

}

model {
 
  true_x ~ normal(0,2);
  sigma_x ~ exponential(1);

  for (n in 1:N) {
    x[n] ~ normal(true_x[n], sigma_x);        // model for true x
  }
  
  y ~ normal(alpha + beta * true_x, sigma_y); // model for y
}

```

Now estimate the model using cmdstanr.

```{r estimate_model1, message = F, warning = F, cache=F}

samp <- latent_x_mod1$sample(
  data = stan_data,
  refresh = 0,
  iter_warmup = 1500,
  iter_sampling = 4000,
  parallel_chains = 4
)
```

Here are the estimates from the model. 


```{r estimates1}

summarise_draws(samp$draws(c("alpha", "beta", "sigma_x")))


```

Compare with regression using the true x variable and one using a simple average of the replicated measurements: 

```{r compare}

broom::tidy(lm(y ~ true_x, data = d))

d$raw_mean <- rowMeans(d[,3:4])

broom::tidy(lm(y ~ raw_mean, data = d))

```
